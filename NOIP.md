# NOIP

# 2023

### T1

[题目](https://www.luogu.com.cn/problem/P9868)

#### 初级解法

##### 思路

**本题主要考察了对`选择任意两个单词`和`交换其中任意两个字符`的认识**

+ 对于每一个单词，将整个问题分解成$n$个子问题。每个子问题的内容是能否找到字符串的一个排列方式$s_0$，使得该字符串在这些词典中的字典序最小。

+ 由题意得，一个字符串的字典序最小，当且仅当这个字符串按升序序列排序。
+ 当使得当前字符串字典序最小时，也要使得其他字符串的字典序最大，也就是使其他字符串按降序排列。

因此可以进而想到，读入时直接对字符串进行排序，并且找到降序字典序最小的字符串，设为$S_{min}$。

对于每个字符串，只需要比较升序排列与$S_{min}$之间的关系：

+   若比$S_{min}$小或当前字符串就是$S_{min}$对应的字符串，则为$1$
+   若比$S_{min}$大，则为$0$

##### 理论时间复杂度

$\Theta(nm(m+\log m))$ 瓶颈在于排序的 $\Theta(m\log m)$

##### 具体用时

![image-20231123175347430](E:\Documents\assets\image-20231123175347430.png)

#### 高级一点的解法~~（贪心大神）~~

##### 思路

考虑贪心

+   找到一个字符串中最大的值与最小的值
    +   将最大的值与首字母交换位置，得到字符串$S_{max}$
    +   将最小的值与首字母交换位置，得到字符串$S_{min}$
+   对于每个字符串$S_i$，只需要比较$S_{i_{min}}$和$\min \limits_{0<j\leq n} (S_{j_{max}})$的大小

##### 正确性证明（为什么只需要交换首字母）

对于两个字符串$S_a$和$S_b$（$S_a \neq S_b$）

+   若$S_{a_{min}}[0]>S_{b_{max}}[0]$，则证明无法通过构造一个更小的$S_{a_{min}}$使得$S_a$满足条件
    +   解释：$S_{a_{min}}[0]$代表了$S_a$中最小的字符，$S_{a_{min}}[0]>S_{b_{max}}[0]$则意味着$S_a$中最小的字符都比$S_b$中最大的字符大，一定不成立
    +   直接输出0
+   若$S_{a_{min}}[0]<S_{b_{max}}[0]$，当前的$S_a$构造已经符合条件，直接输出1
+   若$S_{a_{min}}[0] = S_{b_{max}}[0]$，也可以得出$S_a$是不符合条件的
    +   由$S_{min}$的定义可得$\forall i\in(0, |S_{min}|), S_{min}[i] \geq S_{min}[0]$
    +   由$S_{max}$的定义可得$\forall i \in (0, |S_{max}|), S_{max}[i] \leq S_{max}[0]$
    +   由上述两个性质可得$\forall i \in (0,m),S_{a_{min}}[i] \geq S_{b_{max}}[i]$
    +   又由于没有任何两个字符串是相等的，所以$S_{a_{min}}\neq S_{b_{max}}$
    +   由此可知不成立，输出1

##### 理论时间复杂度

$\Theta(nm^2)$

##### 具体用时

![image-20231123182044413](E:\Documents\assets\image-20231123182044413.png)

#### 目前最佳解法

##### 思路

由第一个解法可得，瓶颈在于`sort()`的$\Theta(m\log m)$

+   将`sort()`改为计数排序（一共就26个字母）
+   同时不保存原字符串，改为保存计数排序统计的26个字母的出现次数

设

+   数组$D_{i,j}$代表第$i$个字符串的第$j$个字母的出现次数
+   数组$P_{i}$表示第$i$个字符串的出现过的最小字母
+   数组$L_i$表示第$i$个字符串的出现过的最大字母

$S_a$和$S_b$可通过一定的构造方式，使得$S_a < S_b$，当且仅当$P_a<L_b$（结合第二种解法的贪心思路）

##### 额外操作~~（卡常）~~

+   读入时读入单个字符，直接在$D$、$P$、$L$数组上修改
+   使用`fputc`和`fgetc`

##### 理论时间复杂度

$\Theta(nm)$（已达理论时间复杂度下限）

##### 理论空间复杂度

$\Theta(n)$

##### 具体用时

![image-20231123183649090](E:\Documents\assets\image-20231123183649090.png)

本地实测数据$n=12000,m=12000$用时`0.89s`

### T2

[~~很抽象的~~题目](https://www.luogu.com.cn/problem/P9869)

**需要注意到的几个特性**

+   若一个变量的值一定不为`U`，那么这个变量的值是`T`还是`F`对结果无影响
+   在执行过程中，变量的值只与最后指向变量的值有关

根据以上两条性质，可以推出：

+   若一个变量为`U`，则最终状态指向该变量的其他变量的值都为`U`
+   若一个变量不为`U`，且未指向其他变量（未被赋值），那么这个变量是`T`还是`F`无所谓（不影响结果）
+   若一个变量不为`U`，且指向了其他变量，那么它的值一定能被其他变量确定出来，且不为`U`

#### 并查集解法

##### 思路

使用拓展域并查集，分别维护**值域**和**相反值域**

+   为了避免在线操作的一系列问题（难以路径压缩，不便于判定等），使用一个数组${to}_i$代表第$i$个数最后指向的序号
+   新建两个点，这两个点代表常值，可以很好的解决直接赋值操作的特判问题
    +   一个点代表`T`，它的相反值代表`F`
    +   另一个点代表`U`，它的相反值仍为`U`

##### AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;
constexpr int N = 1e5+10;
int fa[N * 2], to[N * 2], tot, n, m, c, t, k, x, y, ans = 0;
char op;
int get(int x) { return fa[x] == x ? x : fa[x] = get(fa[x]); }
void merge(int x, int y) { fa[get(x)] = get(y); }
int main() {
    cin.tie(0)->sync_with_stdio(0);
    cin >> c >> t;
    while (t--) {
        cin >> n >>m;
        k = n + 2, tot = k * 2, ans = 0;
        for (int i = 1; i < N * 2; ++i) fa[i] = i, to[i] = i;
        merge(k, tot);
        for (int i = 0; i < m; ++i) {
            cin >> op >> x;
            if (op == 'T') {
                to[x] = n + 1;
            } else if (op == 'U') {
                to[x] = k;
            } else if (op == 'F') {
                to[x] = tot - 1;
            } else if (op == '+') {
                cin >> y;
                to[x] = to[y];
            } else if (op == '-') {
                cin >> y;
                to[x] = to[y] + (to[y] > k ? -k : k);
            }
        }
        for (int i = 1; i <= n; ++i) merge(i, to[i]), merge(i + k, to[i] + (to[i] > k ? -k : k));
        for (int i = 1; i <= n; ++i) if (get(i) == get(i + k)) ++ans;
        cout << ans << '\n';
    }
    return 0;
}
```

